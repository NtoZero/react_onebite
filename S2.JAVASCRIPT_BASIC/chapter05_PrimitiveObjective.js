/* 원시 타입 */
/* 1. 실제 메모리의 값은 수정되지 않음 (불변값) */
// 메모리 어느곳에 1 새롭게 저장
let p1 = 1;
// 메모리 어느곳에 1 새롭게 저장
let p2 = p1;
// 메모리 어느곳에 2 새롭게 저장
p2 = 2;

/* 객체 타입 */

/* 1. 가변 값이다. (실제 메모리의 값을 수정) */
let o1 = { name: "이정환" };
// o1에는 참조값, 별도의 메모리 공간을 가리키는 주소 0x0000C가 저장. 그 주소로
// 객체는 동적인 메모리를 갖기 때문.
// o2에는 0x0000C가 저장. 원시 타입과 다르다.
let o2 = o1;

/* 주1. 의도치 않게 값이 수정될 수 있다. (얕은 복사 - 객체의 참조값을 복사함) */
o2.name = "홍길동"; // o1의 값이 의도치 않게 변경되는 사이드 이펙트 발생 가능

/* 주1-1. 스프레드 연산자를 이용하자. (깊은 복사 - 새로운 객체를 생성하면서 프로퍼티만 따로 복사함) */
let o3 = { ...o1 }; // 새로운 메모리 공간에 주소 및 객체 저장
// console.log(o3)     // {name: '홍길동'}
// o2.name = "김길동";
// console.log(o2.name) // 김길동
// console.log(o3.name) // 홍길동

/* 주2. (얕은 비교) 객체간의 비교는 기본적으로 참조값을 기준으로 이루어진다. */
// console.log(o1, o2, o3);
console.log(o1 === o2); // true
console.log(o1 === o3); // false

/* 주2-1. (깊은 비교) 내장함수 JSON.stringify() 를 이용 => 객체를 문자열로 변환하여 비교*/
console.log(JSON.stringify(o1) === JSON.stringify(o3));

/* 주3. 배열과 함수도 사실 객체이다. */
// 1. 함수(Function) 추가된 기능 호출, 선언, ...
// 2. 배열(Array) 추가된 기능 순차 저장, 순회, ...
